<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>ROS2 Control: mock_components::GenericSystem Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">ROS2 Control
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><b>mock_components</b></li><li class="navelem"><a class="el" href="classmock__components_1_1GenericSystem.html">GenericSystem</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pro-attribs">Protected Attributes</a> &#124;
<a href="classmock__components_1_1GenericSystem-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">mock_components::GenericSystem Class Reference</div>  </div>
</div><!--header-->
<div class="contents">
<div class="dynheader">
Inheritance diagram for mock_components::GenericSystem:</div>
<div class="dyncontent">
<div class="center"><img src="classmock__components_1_1GenericSystem__inherit__graph.png" border="0" usemap="#amock__components_1_1GenericSystem_inherit__map" alt="Inheritance graph"/></div>
<map name="amock__components_1_1GenericSystem_inherit__map" id="amock__components_1_1GenericSystem_inherit__map">
<area shape="rect" title=" " alt="" coords="30,184,233,225"/>
<area shape="rect" href="classhardware__interface_1_1SystemInterface.html" title=" " alt="" coords="57,95,205,136"/>
<area shape="rect" title=" " alt="" coords="5,5,257,47"/>
</map>
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center></div>
<div class="dynheader">
Collaboration diagram for mock_components::GenericSystem:</div>
<div class="dyncontent">
<div class="center"><img src="classmock__components_1_1GenericSystem__coll__graph.png" border="0" usemap="#amock__components_1_1GenericSystem_coll__map" alt="Collaboration graph"/></div>
<map name="amock__components_1_1GenericSystem_coll__map" id="amock__components_1_1GenericSystem_coll__map">
<area shape="rect" title=" " alt="" coords="540,39,743,80"/>
<area shape="rect" href="classhardware__interface_1_1SystemInterface.html" title=" " alt="" coords="343,39,491,80"/>
<area shape="rect" title=" " alt="" coords="5,5,257,47"/>
<area shape="rect" href="structhardware__interface_1_1HardwareInfo.html" title="This structure stores information about hardware defined in a robot&#39;s URDF." alt="" coords="57,71,205,112"/>
</map>
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmock__components_1_1GenericSystem_1_1MimicJoint.html">MimicJoint</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a8529dd633737e4f5d355c8e615aec1a3"><td class="memItemLeft" align="right" valign="top">CallbackReturn&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmock__components_1_1GenericSystem.html#a8529dd633737e4f5d355c8e615aec1a3">on_init</a> (const <a class="el" href="structhardware__interface_1_1HardwareInfo.html">hardware_interface::HardwareInfo</a> &amp;info) override</td></tr>
<tr class="memdesc:a8529dd633737e4f5d355c8e615aec1a3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialization of the hardware interface from data parsed from the robot's URDF.  <a href="classmock__components_1_1GenericSystem.html#a8529dd633737e4f5d355c8e615aec1a3">More...</a><br /></td></tr>
<tr class="separator:a8529dd633737e4f5d355c8e615aec1a3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3b5064b009383dd1af323a20ccd79fb4"><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="classhardware__interface_1_1StateInterface.html">hardware_interface::StateInterface</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmock__components_1_1GenericSystem.html#a3b5064b009383dd1af323a20ccd79fb4">export_state_interfaces</a> () override</td></tr>
<tr class="memdesc:a3b5064b009383dd1af323a20ccd79fb4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Exports all state interfaces for this hardware interface.  <a href="classmock__components_1_1GenericSystem.html#a3b5064b009383dd1af323a20ccd79fb4">More...</a><br /></td></tr>
<tr class="separator:a3b5064b009383dd1af323a20ccd79fb4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac81e256d891bb32aa9d6e6a5727ea55d"><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="classhardware__interface_1_1CommandInterface.html">hardware_interface::CommandInterface</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmock__components_1_1GenericSystem.html#ac81e256d891bb32aa9d6e6a5727ea55d">export_command_interfaces</a> () override</td></tr>
<tr class="memdesc:ac81e256d891bb32aa9d6e6a5727ea55d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Exports all command interfaces for this hardware interface.  <a href="classmock__components_1_1GenericSystem.html#ac81e256d891bb32aa9d6e6a5727ea55d">More...</a><br /></td></tr>
<tr class="separator:ac81e256d891bb32aa9d6e6a5727ea55d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa783edd32f21fff60c1c1073586a1da5"><td class="memItemLeft" align="right" valign="top">return_type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmock__components_1_1GenericSystem.html#aa783edd32f21fff60c1c1073586a1da5">prepare_command_mode_switch</a> (const std::vector&lt; std::string &gt; &amp;start_interfaces, const std::vector&lt; std::string &gt; &amp;stop_interfaces) override</td></tr>
<tr class="memdesc:aa783edd32f21fff60c1c1073586a1da5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Prepare for a new command interface switch.  <a href="classmock__components_1_1GenericSystem.html#aa783edd32f21fff60c1c1073586a1da5">More...</a><br /></td></tr>
<tr class="separator:aa783edd32f21fff60c1c1073586a1da5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a719bc50550c599b2b0e5d45da6f28c0e"><td class="memItemLeft" align="right" valign="top">return_type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmock__components_1_1GenericSystem.html#a719bc50550c599b2b0e5d45da6f28c0e">perform_command_mode_switch</a> (const std::vector&lt; std::string &gt; &amp;start_interfaces, const std::vector&lt; std::string &gt; &amp;stop_interfaces) override</td></tr>
<tr class="separator:a719bc50550c599b2b0e5d45da6f28c0e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a87246468061271ca2121f156d871b1c0"><td class="memItemLeft" align="right" valign="top">return_type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmock__components_1_1GenericSystem.html#a87246468061271ca2121f156d871b1c0">read</a> (const rclcpp::Time &amp;time, const rclcpp::Duration &amp;period) override</td></tr>
<tr class="memdesc:a87246468061271ca2121f156d871b1c0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read the current state values from the actuator.  <a href="classmock__components_1_1GenericSystem.html#a87246468061271ca2121f156d871b1c0">More...</a><br /></td></tr>
<tr class="separator:a87246468061271ca2121f156d871b1c0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a64e4042a2824dcc04dde6a373a2eb84a"><td class="memItemLeft" align="right" valign="top">return_type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmock__components_1_1GenericSystem.html#a64e4042a2824dcc04dde6a373a2eb84a">write</a> (const rclcpp::Time &amp;, const rclcpp::Duration &amp;) override</td></tr>
<tr class="memdesc:a64e4042a2824dcc04dde6a373a2eb84a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Write the current command values to the actuator.  <a href="classmock__components_1_1GenericSystem.html#a64e4042a2824dcc04dde6a373a2eb84a">More...</a><br /></td></tr>
<tr class="separator:a64e4042a2824dcc04dde6a373a2eb84a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_classhardware__interface_1_1SystemInterface"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_classhardware__interface_1_1SystemInterface')"><img src="closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="classhardware__interface_1_1SystemInterface.html">hardware_interface::SystemInterface</a></td></tr>
<tr class="memitem:af117bf00b006cc998f49398ca5a6bab4 inherit pub_methods_classhardware__interface_1_1SystemInterface"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhardware__interface_1_1SystemInterface.html#af117bf00b006cc998f49398ca5a6bab4">SystemInterface</a> (const <a class="el" href="classhardware__interface_1_1SystemInterface.html">SystemInterface</a> &amp;other)=delete</td></tr>
<tr class="memdesc:af117bf00b006cc998f49398ca5a6bab4 inherit pub_methods_classhardware__interface_1_1SystemInterface"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classhardware__interface_1_1SystemInterface.html">SystemInterface</a> copy constructor is actively deleted.  <a href="classhardware__interface_1_1SystemInterface.html#af117bf00b006cc998f49398ca5a6bab4">More...</a><br /></td></tr>
<tr class="separator:af117bf00b006cc998f49398ca5a6bab4 inherit pub_methods_classhardware__interface_1_1SystemInterface"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2c479dbc6d2330c193ef4b2eea981845 inherit pub_methods_classhardware__interface_1_1SystemInterface"><td class="memItemLeft" align="right" valign="top"><a id="a2c479dbc6d2330c193ef4b2eea981845"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>SystemInterface</b> (<a class="el" href="classhardware__interface_1_1SystemInterface.html">SystemInterface</a> &amp;&amp;other)=default</td></tr>
<tr class="separator:a2c479dbc6d2330c193ef4b2eea981845 inherit pub_methods_classhardware__interface_1_1SystemInterface"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4d09669f014b01d525bebca4f0ea30df inherit pub_methods_classhardware__interface_1_1SystemInterface"><td class="memItemLeft" align="right" valign="top">virtual std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhardware__interface_1_1SystemInterface.html#a4d09669f014b01d525bebca4f0ea30df">get_name</a> () const</td></tr>
<tr class="memdesc:a4d09669f014b01d525bebca4f0ea30df inherit pub_methods_classhardware__interface_1_1SystemInterface"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get name of the actuator hardware.  <a href="classhardware__interface_1_1SystemInterface.html#a4d09669f014b01d525bebca4f0ea30df">More...</a><br /></td></tr>
<tr class="separator:a4d09669f014b01d525bebca4f0ea30df inherit pub_methods_classhardware__interface_1_1SystemInterface"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ace72c52db45e831af39d3d74d32815b5 inherit pub_methods_classhardware__interface_1_1SystemInterface"><td class="memItemLeft" align="right" valign="top">const rclcpp_lifecycle::State &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhardware__interface_1_1SystemInterface.html#ace72c52db45e831af39d3d74d32815b5">get_state</a> () const</td></tr>
<tr class="memdesc:ace72c52db45e831af39d3d74d32815b5 inherit pub_methods_classhardware__interface_1_1SystemInterface"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get life-cycle state of the actuator hardware.  <a href="classhardware__interface_1_1SystemInterface.html#ace72c52db45e831af39d3d74d32815b5">More...</a><br /></td></tr>
<tr class="separator:ace72c52db45e831af39d3d74d32815b5 inherit pub_methods_classhardware__interface_1_1SystemInterface"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3858c2c61a073939992814bd3f0e9a63 inherit pub_methods_classhardware__interface_1_1SystemInterface"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhardware__interface_1_1SystemInterface.html#a3858c2c61a073939992814bd3f0e9a63">set_state</a> (const rclcpp_lifecycle::State &amp;new_state)</td></tr>
<tr class="memdesc:a3858c2c61a073939992814bd3f0e9a63 inherit pub_methods_classhardware__interface_1_1SystemInterface"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set life-cycle state of the actuator hardware.  <a href="classhardware__interface_1_1SystemInterface.html#a3858c2c61a073939992814bd3f0e9a63">More...</a><br /></td></tr>
<tr class="separator:a3858c2c61a073939992814bd3f0e9a63 inherit pub_methods_classhardware__interface_1_1SystemInterface"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-attribs"></a>
Protected Attributes</h2></td></tr>
<tr class="memitem:aa6d5c94e327b940ed50ccb4c65b6288c"><td class="memItemLeft" align="right" valign="top">const std::vector&lt; std::string &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmock__components_1_1GenericSystem.html#aa6d5c94e327b940ed50ccb4c65b6288c">standard_interfaces_</a></td></tr>
<tr class="memdesc:aa6d5c94e327b940ed50ccb4c65b6288c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Use standard interfaces for joints because they are relevant for dynamic behavior.  <a href="classmock__components_1_1GenericSystem.html#aa6d5c94e327b940ed50ccb4c65b6288c">More...</a><br /></td></tr>
<tr class="separator:aa6d5c94e327b940ed50ccb4c65b6288c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af57f234d8017085ee844138930956770"><td class="memItemLeft" align="right" valign="top"><a id="af57f234d8017085ee844138930956770"></a>
std::vector&lt; <a class="el" href="structmock__components_1_1GenericSystem_1_1MimicJoint.html">MimicJoint</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>mimic_joints_</b></td></tr>
<tr class="separator:af57f234d8017085ee844138930956770"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9889bd21f48bb371d1bf175ab68804d8"><td class="memItemLeft" align="right" valign="top"><a id="a9889bd21f48bb371d1bf175ab68804d8"></a>
std::vector&lt; std::vector&lt; double &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmock__components_1_1GenericSystem.html#a9889bd21f48bb371d1bf175ab68804d8">joint_commands_</a></td></tr>
<tr class="memdesc:a9889bd21f48bb371d1bf175ab68804d8"><td class="mdescLeft">&#160;</td><td class="mdescRight">The size of this vector is (standard_interfaces_.size() x nr_joints) <br /></td></tr>
<tr class="separator:a9889bd21f48bb371d1bf175ab68804d8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aed64df1cd526ec9671d224bbcfd9c468"><td class="memItemLeft" align="right" valign="top"><a id="aed64df1cd526ec9671d224bbcfd9c468"></a>
std::vector&lt; std::vector&lt; double &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>joint_states_</b></td></tr>
<tr class="separator:aed64df1cd526ec9671d224bbcfd9c468"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af0a3a5a8580341e2086467c1c3c72e6f"><td class="memItemLeft" align="right" valign="top"><a id="af0a3a5a8580341e2086467c1c3c72e6f"></a>
std::vector&lt; std::string &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>other_interfaces_</b></td></tr>
<tr class="separator:af0a3a5a8580341e2086467c1c3c72e6f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab9850523086de0d92cbf5bf7186e5599"><td class="memItemLeft" align="right" valign="top"><a id="ab9850523086de0d92cbf5bf7186e5599"></a>
std::vector&lt; std::vector&lt; double &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmock__components_1_1GenericSystem.html#ab9850523086de0d92cbf5bf7186e5599">other_commands_</a></td></tr>
<tr class="memdesc:ab9850523086de0d92cbf5bf7186e5599"><td class="mdescLeft">&#160;</td><td class="mdescRight">The size of this vector is (other_interfaces_.size() x nr_joints) <br /></td></tr>
<tr class="separator:ab9850523086de0d92cbf5bf7186e5599"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a876ab6c1179c799819e5a486097cf711"><td class="memItemLeft" align="right" valign="top"><a id="a876ab6c1179c799819e5a486097cf711"></a>
std::vector&lt; std::vector&lt; double &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>other_states_</b></td></tr>
<tr class="separator:a876ab6c1179c799819e5a486097cf711"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae1747bd2667198634c4ada5dbfea1fb7"><td class="memItemLeft" align="right" valign="top"><a id="ae1747bd2667198634c4ada5dbfea1fb7"></a>
std::vector&lt; std::string &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>sensor_interfaces_</b></td></tr>
<tr class="separator:ae1747bd2667198634c4ada5dbfea1fb7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aba07133d89f71de0330dd45587fba77c"><td class="memItemLeft" align="right" valign="top"><a id="aba07133d89f71de0330dd45587fba77c"></a>
std::vector&lt; std::vector&lt; double &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmock__components_1_1GenericSystem.html#aba07133d89f71de0330dd45587fba77c">sensor_mock_commands_</a></td></tr>
<tr class="memdesc:aba07133d89f71de0330dd45587fba77c"><td class="mdescLeft">&#160;</td><td class="mdescRight">The size of this vector is (sensor_interfaces_.size() x nr_joints) <br /></td></tr>
<tr class="separator:aba07133d89f71de0330dd45587fba77c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af0f4a5b4929ab5cff0cc0b5b57800400"><td class="memItemLeft" align="right" valign="top"><a id="af0f4a5b4929ab5cff0cc0b5b57800400"></a>
std::vector&lt; std::vector&lt; double &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>sensor_states_</b></td></tr>
<tr class="separator:af0f4a5b4929ab5cff0cc0b5b57800400"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3280d3c1f4476f67932078204ebefa9b"><td class="memItemLeft" align="right" valign="top"><a id="a3280d3c1f4476f67932078204ebefa9b"></a>
std::vector&lt; std::string &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>gpio_interfaces_</b></td></tr>
<tr class="separator:a3280d3c1f4476f67932078204ebefa9b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abf862830f5caf481e76222b315c77aa2"><td class="memItemLeft" align="right" valign="top"><a id="abf862830f5caf481e76222b315c77aa2"></a>
std::vector&lt; std::vector&lt; double &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmock__components_1_1GenericSystem.html#abf862830f5caf481e76222b315c77aa2">gpio_mock_commands_</a></td></tr>
<tr class="memdesc:abf862830f5caf481e76222b315c77aa2"><td class="mdescLeft">&#160;</td><td class="mdescRight">The size of this vector is (gpio_interfaces_.size() x nr_joints) <br /></td></tr>
<tr class="separator:abf862830f5caf481e76222b315c77aa2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4ba09135104c5c46643a0d3a2994b913"><td class="memItemLeft" align="right" valign="top"><a id="a4ba09135104c5c46643a0d3a2994b913"></a>
std::vector&lt; std::vector&lt; double &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>gpio_commands_</b></td></tr>
<tr class="separator:a4ba09135104c5c46643a0d3a2994b913"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ace6f27b2770c4dd967606c79620edff6"><td class="memItemLeft" align="right" valign="top"><a id="ace6f27b2770c4dd967606c79620edff6"></a>
std::vector&lt; std::vector&lt; double &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>gpio_states_</b></td></tr>
<tr class="separator:ace6f27b2770c4dd967606c79620edff6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pro_attribs_classhardware__interface_1_1SystemInterface"><td colspan="2" onclick="javascript:toggleInherit('pro_attribs_classhardware__interface_1_1SystemInterface')"><img src="closed.png" alt="-"/>&#160;Protected Attributes inherited from <a class="el" href="classhardware__interface_1_1SystemInterface.html">hardware_interface::SystemInterface</a></td></tr>
<tr class="memitem:a8614be4ed58eac9c0c5f8ba096454550 inherit pro_attribs_classhardware__interface_1_1SystemInterface"><td class="memItemLeft" align="right" valign="top"><a id="a8614be4ed58eac9c0c5f8ba096454550"></a>
<a class="el" href="structhardware__interface_1_1HardwareInfo.html">HardwareInfo</a>&#160;</td><td class="memItemRight" valign="bottom"><b>info_</b></td></tr>
<tr class="separator:a8614be4ed58eac9c0c5f8ba096454550 inherit pro_attribs_classhardware__interface_1_1SystemInterface"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5ccfcd637715cc0c64c4537fd09e74ee inherit pro_attribs_classhardware__interface_1_1SystemInterface"><td class="memItemLeft" align="right" valign="top"><a id="a5ccfcd637715cc0c64c4537fd09e74ee"></a>
rclcpp_lifecycle::State&#160;</td><td class="memItemRight" valign="bottom"><b>lifecycle_state_</b></td></tr>
<tr class="separator:a5ccfcd637715cc0c64c4537fd09e74ee inherit pro_attribs_classhardware__interface_1_1SystemInterface"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="ac81e256d891bb32aa9d6e6a5727ea55d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac81e256d891bb32aa9d6e6a5727ea55d">&#9670;&nbsp;</a></span>export_command_interfaces()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; <a class="el" href="classhardware__interface_1_1CommandInterface.html">hardware_interface::CommandInterface</a> &gt; mock_components::GenericSystem::export_command_interfaces </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Exports all command interfaces for this hardware interface. </p>
<p>The command interfaces have to be created and transferred according to the hardware info passed in for the configuration.</p>
<p>Note the ownership over the state interfaces is transferred to the caller.</p>
<dl class="section return"><dt>Returns</dt><dd>vector of command interfaces </dd></dl>

<p>Implements <a class="el" href="classhardware__interface_1_1SystemInterface.html#a9891f7b526cd97e3e9e9b8db0c7ba088">hardware_interface::SystemInterface</a>.</p>

</div>
</div>
<a id="a3b5064b009383dd1af323a20ccd79fb4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3b5064b009383dd1af323a20ccd79fb4">&#9670;&nbsp;</a></span>export_state_interfaces()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; <a class="el" href="classhardware__interface_1_1StateInterface.html">hardware_interface::StateInterface</a> &gt; mock_components::GenericSystem::export_state_interfaces </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Exports all state interfaces for this hardware interface. </p>
<p>The state interfaces have to be created and transferred according to the hardware info passed in for the configuration.</p>
<p>Note the ownership over the state interfaces is transferred to the caller.</p>
<dl class="section return"><dt>Returns</dt><dd>vector of state interfaces </dd></dl>

<p>Implements <a class="el" href="classhardware__interface_1_1SystemInterface.html#a4cf4136dc098adb0e7f95a9f3ba69286">hardware_interface::SystemInterface</a>.</p>

</div>
</div>
<a id="a8529dd633737e4f5d355c8e615aec1a3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8529dd633737e4f5d355c8e615aec1a3">&#9670;&nbsp;</a></span>on_init()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">CallbackReturn mock_components::GenericSystem::on_init </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structhardware__interface_1_1HardwareInfo.html">hardware_interface::HardwareInfo</a> &amp;&#160;</td>
          <td class="paramname"><em>hardware_info</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Initialization of the hardware interface from data parsed from the robot's URDF. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">hardware_info</td><td>structure with data from URDF. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>CallbackReturn::SUCCESS if required data are provided and can be parsed. </dd>
<dd>
CallbackReturn::ERROR if any error happens or data are missing. </dd></dl>

<p>Reimplemented from <a class="el" href="classhardware__interface_1_1SystemInterface.html#a4e92fac1a9d82e418452bf597edd22e0">hardware_interface::SystemInterface</a>.</p>

</div>
</div>
<a id="a719bc50550c599b2b0e5d45da6f28c0e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a719bc50550c599b2b0e5d45da6f28c0e">&#9670;&nbsp;</a></span>perform_command_mode_switch()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">return_type mock_components::GenericSystem::perform_command_mode_switch </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; std::string &gt; &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; std::string &gt; &amp;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Perform the mode-switching for the new command interface combination.</p>
<dl class="section note"><dt>Note</dt><dd>This is part of the realtime update loop, and should be fast. </dd>
<dd>
All starting and stopping interface keys are passed to all components, so the function should return return_type::OK by default when given interface keys not relevant for this component.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">start_interfaces</td><td>vector of string identifiers for the command interfaces starting.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">stop_interfaces</td><td>vector of string identifiers for the command interfacs stopping. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>return_type::OK if the new command interface combination can be switched to, or if the interface key is not relevant to this system. Returns return_type::ERROR otherwise. </dd></dl>

<p>Reimplemented from <a class="el" href="classhardware__interface_1_1SystemInterface.html#a1da44ec2a9ef354e056e2dac3e95682f">hardware_interface::SystemInterface</a>.</p>

</div>
</div>
<a id="aa783edd32f21fff60c1c1073586a1da5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa783edd32f21fff60c1c1073586a1da5">&#9670;&nbsp;</a></span>prepare_command_mode_switch()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">return_type mock_components::GenericSystem::prepare_command_mode_switch </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; std::string &gt; &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; std::string &gt; &amp;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Prepare for a new command interface switch. </p>
<p>Prepare for any mode-switching required by the new command interface combination.</p>
<dl class="section note"><dt>Note</dt><dd>This is a non-realtime evaluation of whether a set of command interface claims are possible, and call to start preparing data structures for the upcoming switch that will occur. </dd>
<dd>
All starting and stopping interface keys are passed to all components, so the function should return return_type::OK by default when given interface keys not relevant for this component.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">start_interfaces</td><td>vector of string identifiers for the command interfaces starting.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">stop_interfaces</td><td>vector of string identifiers for the command interfacs stopping. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>return_type::OK if the new command interface combination can be prepared, or if the interface key is not relevant to this system. Returns return_type::ERROR otherwise. </dd></dl>

<p>Reimplemented from <a class="el" href="classhardware__interface_1_1SystemInterface.html#a9b944943314be907806ec3e989e6acd9">hardware_interface::SystemInterface</a>.</p>

</div>
</div>
<a id="a87246468061271ca2121f156d871b1c0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a87246468061271ca2121f156d871b1c0">&#9670;&nbsp;</a></span>read()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">return_type mock_components::GenericSystem::read </td>
          <td>(</td>
          <td class="paramtype">const rclcpp::Time &amp;&#160;</td>
          <td class="paramname"><em>time</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const rclcpp::Duration &amp;&#160;</td>
          <td class="paramname"><em>period</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Read the current state values from the actuator. </p>
<p>The data readings from the physical hardware has to be updated and reflected accordingly in the exported state interfaces. That is, the data pointed by the interfaces shall be updated.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">time</td><td>The time at the start of this control loop iteration </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">period</td><td>The measured time taken by the last control loop iteration </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>return_type::OK if the read was successful, return_type::ERROR otherwise. </dd></dl>

<p>Implements <a class="el" href="classhardware__interface_1_1SystemInterface.html#ae48a70b6c631787f6891370dd40e018e">hardware_interface::SystemInterface</a>.</p>

</div>
</div>
<a id="a64e4042a2824dcc04dde6a373a2eb84a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a64e4042a2824dcc04dde6a373a2eb84a">&#9670;&nbsp;</a></span>write()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">return_type mock_components::GenericSystem::write </td>
          <td>(</td>
          <td class="paramtype">const rclcpp::Time &amp;&#160;</td>
          <td class="paramname"><em>time</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const rclcpp::Duration &amp;&#160;</td>
          <td class="paramname"><em>period</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Write the current command values to the actuator. </p>
<p>The physical hardware shall be updated with the latest value from the exported command interfaces.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">time</td><td>The time at the start of this control loop iteration </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">period</td><td>The measured time taken by the last control loop iteration </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>return_type::OK if the read was successful, return_type::ERROR otherwise. </dd></dl>

<p>Implements <a class="el" href="classhardware__interface_1_1SystemInterface.html#af50333e4b0b30c9a1d66f296a33a5d8d">hardware_interface::SystemInterface</a>.</p>

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a id="aa6d5c94e327b940ed50ccb4c65b6288c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa6d5c94e327b940ed50ccb4c65b6288c">&#9670;&nbsp;</a></span>standard_interfaces_</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const std::vector&lt;std::string&gt; mock_components::GenericSystem::standard_interfaces_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">= {</div>
<div class="line">    <a class="code" href="namespacehardware__interface.html#adf4658e878804ad412a26773aa4705a6">hardware_interface::HW_IF_POSITION</a>, <a class="code" href="namespacehardware__interface.html#ac92e707f8d468092ae48031e87cacb11">hardware_interface::HW_IF_VELOCITY</a>,</div>
<div class="line">    <a class="code" href="namespacehardware__interface.html#ac2f4024766cc8e328cf568d30e5099c6">hardware_interface::HW_IF_ACCELERATION</a>, <a class="code" href="namespacehardware__interface.html#a51a32aa22fecafedbf00b6fddf4b2dd7">hardware_interface::HW_IF_EFFORT</a>}</div>
<div class="ttc" id="anamespacehardware__interface_html_a51a32aa22fecafedbf00b6fddf4b2dd7"><div class="ttname"><a href="namespacehardware__interface.html#a51a32aa22fecafedbf00b6fddf4b2dd7">hardware_interface::HW_IF_EFFORT</a></div><div class="ttdeci">constexpr char HW_IF_EFFORT[]</div><div class="ttdoc">Constant defining effort interface.</div><div class="ttdef"><b>Definition:</b> hardware_interface_type_values.hpp:27</div></div>
<div class="ttc" id="anamespacehardware__interface_html_ac2f4024766cc8e328cf568d30e5099c6"><div class="ttname"><a href="namespacehardware__interface.html#ac2f4024766cc8e328cf568d30e5099c6">hardware_interface::HW_IF_ACCELERATION</a></div><div class="ttdeci">constexpr char HW_IF_ACCELERATION[]</div><div class="ttdoc">Constant defining acceleration interface.</div><div class="ttdef"><b>Definition:</b> hardware_interface_type_values.hpp:25</div></div>
<div class="ttc" id="anamespacehardware__interface_html_ac92e707f8d468092ae48031e87cacb11"><div class="ttname"><a href="namespacehardware__interface.html#ac92e707f8d468092ae48031e87cacb11">hardware_interface::HW_IF_VELOCITY</a></div><div class="ttdeci">constexpr char HW_IF_VELOCITY[]</div><div class="ttdoc">Constant defining velocity interface.</div><div class="ttdef"><b>Definition:</b> hardware_interface_type_values.hpp:23</div></div>
<div class="ttc" id="anamespacehardware__interface_html_adf4658e878804ad412a26773aa4705a6"><div class="ttname"><a href="namespacehardware__interface.html#adf4658e878804ad412a26773aa4705a6">hardware_interface::HW_IF_POSITION</a></div><div class="ttdeci">constexpr char HW_IF_POSITION[]</div><div class="ttdoc">Constant defining position interface.</div><div class="ttdef"><b>Definition:</b> hardware_interface_type_values.hpp:21</div></div>
</div><!-- fragment -->
<p>Use standard interfaces for joints because they are relevant for dynamic behavior. </p>
<p>By splitting the standard interfaces from other type, the users are able to inherit this class and simply create small "simulation" with desired dynamic behavior. The advantage over using Gazebo is that enables "quick &amp; dirty" tests of robot's URDF and controllers. </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>hardware_interface/include/mock_components/<a class="el" href="generic__system_8hpp_source.html">generic_system.hpp</a></li>
<li>hardware_interface/src/mock_components/generic_system.cpp</li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.1
</small></address>
</body>
</html>
